// #define _USE_MATH_DEFINES

// #include <linalg.hpp>
// #include <mke2.hpp>
// #include <util.hpp>

// #include <cmath>

// using namespace std;

// static constexpr double p = 1e5;            // Па
// static constexpr double mu = 1e3;           // Па/м
// static constexpr double E = 212e9;          // Па
// static constexpr double omega = 2e4 * M_PI; // Гц
// static constexpr double nu = 0.29;          // 1
// static constexpr double rho = 10210;        // кг / м^3

// static constexpr std::array<double, 2> L
//     = {E * nu / ((1 + nu) * (1 - 2 * nu)), E / (2 * (1 + nu))};
// static constexpr std::array<double, 6 * 6> C = {L[0] + 2 * L[1],
//                                                 L[0],
//                                                 L[0],
//                                                 0,
//                                                 0,
//                                                 0, //
//                                                 L[0],
//                                                 L[0] + 2 * L[1],
//                                                 L[0],
//                                                 0,
//                                                 0,
//                                                 0, //
//                                                 L[0],
//                                                 L[0],
//                                                 L[0] + 2 * L[1],
//                                                 0,
//                                                 0,
//                                                 0, //
//                                                 0,
//                                                 0,
//                                                 0,
//                                                 L[1],
//                                                 0,
//                                                 0, //
//                                                 0,
//                                                 0,
//                                                 0,
//                                                 0,
//                                                 L[1],
//                                                 0, //
//                                                 0,
//                                                 0,
//                                                 0,
//                                                 0,
//                                                 0,
//                                                 L[1]};

// DenseMatrix LocalEq::Cm({6, 6}, begin(C), end(C));

// LocalEq::LocalEq(const Triang3d::Node& node)
//     : node_(node)
// {
// }

// LocalEq::Result LocalEq::get()
// {
//     return {get_Bk(), get_fk()};
// }

// array<Vec, 3> LocalEq::get_df()
// {
//     auto r = LupFactor(node_.vertex_view().append_row(Vec(4, 1.))).factor();
//     return {r.solve({1, 0, 0}), r.solve({0, 1, 0}), r.solve({0, 0, 1})};
// }

// DenseMatrix LocalEq::get_DQ()
// {
//     DenseMatrix result({6, 12});

//     auto f = get_df();
//     for (size_t i = 0; i < 4; ++i) {
//         auto j = 3 * i;
//         result(0, j + 0) = f[0][i];
//         result(1, j + 1) = f[1][i];
//         result(2, j + 2) = f[2][i];
//         result(3, j + 0) = f[1][i];
//         result(3, j + 1) = f[0][i];
//         result(4, j + 0) = f[2][i];
//         result(4, j + 2) = f[0][i];
//         result(5, j + 1) = f[2][i];
//         result(5, j + 2) = f[1][i];
//     }

//     return result;
// }

// DenseMatrix LocalEq::get_Gk()
// {
//     auto DQ = get_DQ();
//     auto DQt = DQ.transpose();

//     return DQt * Cm * DQ;
// }

// DenseMatrix LocalEq::get_S0()
// {
//     DenseMatrix result({4, 4}, 1);

//     for (DenseMatrix::Index i = 0; i < 4; ++i) {
//         result(i, i) = 2;
//     }
//     result *= (rho / 120);
//     result = kroneker_product(result, DenseMatrix::eye(3));

//     return result;
// }

// DenseMatrix LocalEq::get_Sb()
// {
//     DenseMatrix result({4, 4});
//     for (auto& i : node_.boundary()) {
//         result += get_bmat(i);
//     }
//     result *= 5 * mu / 120;
//     result = kroneker_product(result, DenseMatrix::eye(3));

//     return result;
// }

// DenseMatrix LocalEq::get_Ub()
// {
//     DenseMatrix result({4, 4});
//     for (auto& i : node_.boundary()) {
//         result += get_bmat(i);
//     }
//     result /= 24;
//     result = kroneker_product(result, DenseMatrix::eye(3));

//     return result;
// }

// DenseMatrix LocalEq::get_bmat(size_t index)
// {
//     DenseMatrix result({4, 4});
//     auto m = (index + 1) % 4;
//     auto n = (index + 2) % 4;
//     auto p = (index + 3) % 4;
//     auto s = norm(cross(node_.v(m) - node_.v(p), node_.v(n) - node_.v(p)));

//     result(m, m) = result(n, n) = result(p, p) = 2;
//     result(m, n) = result(m, p) = result(n, p) = 1;
//     result *= s;

//     return result;
// }

// DenseMatrix LocalEq::get_Bk()
// {
//     auto v = triple(node_.v(0) - node_.v(3), node_.v(1) - node_.v(3),
//                     node_.v(2) - node_.v(3));

//     return v * (get_Gk() / 6 - sqr(omega) * get_S0()) + get_Sb();
// }

// Vec LocalEq::get_fk()
// {
//     Vec t(12);
//     for (size_t i = 0; i < 4; ++i) {
//         t[3 * i + 2] = -p;
//     }

//     return get_Ub() * t;
// }